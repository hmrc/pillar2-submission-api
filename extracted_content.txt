package uk.gov.hmrc.pillar2submissionapi.controllers

import cats.data.Validated
import cats.implicits.toFoldableOps
import play.api.libs.json._
import play.api.mvc.{Action, AnyContent, ControllerComponents}
import uk.gov.hmrc.pillar2submissionapi.models.uktrsubmissions._
import uk.gov.hmrc.pillar2submissionapi.validation._
import uk.gov.hmrc.play.bootstrap.backend.controller.BackendController

import javax.inject.{Inject, Singleton}

@Singleton
class UktrSubmissionController @Inject() (cc: ControllerComponents) extends BackendController(cc) {

  def submitUktr: Action[AnyContent] = Action { request =>
    request.body.asJson match {
      case Some(json) =>
        // Validate for unexpected fields
        val knownTopLevelKeys = Set("accountingPeriodFrom", "accountingPeriodTo", "obligationMTT", "electionUKGAAP", "liabilities")
        val extraTopLevelKeys = json.as[JsObject].keys.diff(knownTopLevelKeys)

        val knownLiabilitiesKeys = Set(
          "electionDTTSingleMember",
          "electionUTPRSingleMember",
          "numberSubGroupDTT",
          "numberSubGroupUTPR",
          "totalLiability",
          "totalLiabilityDTT",
          "totalLiabilityIIR",
          "totalLiabilityUTPR",
          "liableEntities",
          "returnType"
        )
        val extraLiabilitiesKeys = (json \ "liabilities")
          .asOpt[JsObject]
          .map(_.keys.diff(knownLiabilitiesKeys))
          .getOrElse(Set.empty)

        val allExtraKeys = extraTopLevelKeys.map(key => s"Path: /$key, Errors: unexpected field") ++
          extraLiabilitiesKeys.map(key => s"Path: /liabilities/$key, Errors: unexpected field")

        if (allExtraKeys.nonEmpty) {
          BadRequest(
            Json.obj(
              "message" -> "Invalid JSON format",
              "details" -> allExtraKeys
            )
          )
        } else {
          // Proceed with validation
          json.validate[UktrSubmission] match {
            case JsSuccess(submission: UktrSubmissionData, _) =>
              LiabilityDataValidator.validate(submission.liabilities) match {
                case Validated.Valid(_) =>
                  Created(Json.obj("status" -> "Created"))
                case Validated.Invalid(errors) =>
                  BadRequest(
                    Json.obj(
                      "message" -> "Invalid JSON format",
                      "details" -> errors.toList.map(e => s"${e.field}: ${e.error}")
                    )
                  )
              }

            case JsSuccess(submission: UktrSubmissionNilReturn, _) =>
              LiabilityNilReturnValidator.validate(submission.liabilities) match {
                case Validated.Valid(_) =>
                  Created(Json.obj("status" -> "Created"))
                case Validated.Invalid(errors) =>
                  BadRequest(
                    Json.obj(
                      "message" -> "Invalid JSON format",
                      "details" -> errors.toList.map(e => s"${e.field}, Errors: ${e.error}")
                    )
                  )
              }

            case JsError(errors) =>
              val errorDetails = errors.map { case (path, validationErrors) =>
                validationErrors.map(err => s"Path: $path, Errors: ${err.message}")
              }.flatten
              BadRequest(
                Json.obj(
                  "message" -> "Invalid JSON format",
                  "details" -> errorDetails
                )
              )
          }
        }

      case None =>
        BadRequest(Json.obj("message" -> "Invalid JSON format"))
    }
  }
}


package uk.gov.hmrc.pillar2submissionapi.models.uktrsubmissions

abstract class Liability


package uk.gov.hmrc.pillar2submissionapi.models.uktrsubmissions

import play.api.libs.json.{Json, OFormat}

case class LiabilityData(
  electionDTTSingleMember:  Boolean,
  electionUTPRSingleMember: Boolean,
  numberSubGroupDTT:        Int,
  numberSubGroupUTPR:       Int,
  totalLiability:           BigDecimal,
  totalLiabilityDTT:        BigDecimal,
  totalLiabilityIIR:        BigDecimal,
  totalLiabilityUTPR:       BigDecimal,
  liableEntities:           Seq[LiableEntity]
) extends Liability

object LiabilityData {
  implicit val liabilityDataFormat: OFormat[LiabilityData] = Json.format[LiabilityData]
}


package uk.gov.hmrc.pillar2submissionapi.models.uktrsubmissions

import play.api.libs.json.{Json, OFormat}

case class LiabilityNilReturn(returnType: ReturnType) extends Liability

object LiabilityNilReturn {
  implicit val liabilityNilReturnFormat: OFormat[LiabilityNilReturn] = Json.format[LiabilityNilReturn]
}


package uk.gov.hmrc.pillar2submissionapi.models.uktrsubmissions

import play.api.libs.json.{Json, OFormat}

case class LiableEntity(
  ukChargeableEntityName: String,
  idType:                 String,
  idValue:                String,
  amountOwedDTT:          BigDecimal,
  amountOwedIIR:          BigDecimal,
  amountOwedUTPR:         BigDecimal
)

object LiableEntity {
  implicit val format: OFormat[LiableEntity] = Json.format[LiableEntity]
}


package uk.gov.hmrc.pillar2submissionapi.models.uktrsubmissions

import enumeratum.EnumEntry.UpperSnakecase
import enumeratum._

sealed trait ReturnType extends EnumEntry with UpperSnakecase

object ReturnType extends Enum[ReturnType] with PlayJsonEnum[ReturnType] {

  val values: IndexedSeq[ReturnType] = findValues

  case object NIL_RETURN extends ReturnType
}


package uk.gov.hmrc.pillar2submissionapi.models.uktrsubmissions

import play.api.libs.json._

import java.time.LocalDate

sealed trait UktrSubmission {
  val accountingPeriodFrom: LocalDate
  val accountingPeriodTo:   LocalDate
  val obligationMTT:        Boolean
  val electionUKGAAP:       Boolean
  val liabilities:          Liability
}

object UktrSubmission {
  implicit val uktrSubmissionReads: Reads[UktrSubmission] = Reads { json =>
    (json \ "liabilities" \ "returnType").validateOpt[String] match {
      case JsSuccess(Some(returnTypeStr), _) =>
        ReturnType.withNameOption(returnTypeStr) match {
          case Some(ReturnType.NIL_RETURN) =>
            json.validate[UktrSubmissionNilReturn]
          case Some(_) =>
            json.validate[UktrSubmissionData]
          case None =>
            JsError(JsPath \ "liabilities" \ "returnType", JsonValidationError(s"Unknown submission type: $returnTypeStr"))
        }
      case JsSuccess(None, _) =>
        JsError(JsPath \ "liabilities" \ "returnType", JsonValidationError("error.path.missing"))
      case JsError(errors) =>
        JsError(errors)
    }
  }

  implicit val writes: Writes[UktrSubmission] = Writes[UktrSubmission] {
    case data:      UktrSubmissionData      => Json.toJson(data)
    case nilReturn: UktrSubmissionNilReturn => Json.toJson(nilReturn)
  }
}

case class UktrSubmissionData(
  accountingPeriodFrom: LocalDate,
  accountingPeriodTo:   LocalDate,
  obligationMTT:        Boolean,
  electionUKGAAP:       Boolean,
  liabilities:          LiabilityData
) extends UktrSubmission

object UktrSubmissionData {
  implicit val uktrSubmissionDataFormat: OFormat[UktrSubmissionData] = Json.format[UktrSubmissionData]
}

case class UktrSubmissionNilReturn(
  accountingPeriodFrom: LocalDate,
  accountingPeriodTo:   LocalDate,
  obligationMTT:        Boolean,
  electionUKGAAP:       Boolean,
  liabilities:          LiabilityNilReturn
) extends UktrSubmission

object UktrSubmissionNilReturn {
  implicit val uktrSubmissionNilReturnFormat: OFormat[UktrSubmissionNilReturn] = Json.format[UktrSubmissionNilReturn]
}


package uk.gov.hmrc.pillar2submissionapi.validation

import cats.data.ValidatedNec
import cats.implicits._
import uk.gov.hmrc.pillar2submissionapi.models.uktrsubmissions._

object LiabilityDataValidator extends Validator[LiabilityData] {
  override def validate(obj: LiabilityData): ValidatedNec[ValidationError, LiabilityData] =
    (
      validateNonNegativeInt(obj.numberSubGroupDTT, "numberSubGroupDTT"),
      validateNonNegativeInt(obj.numberSubGroupUTPR, "numberSubGroupUTPR"),
      validatePositiveBigDecimal(obj.totalLiability, "totalLiability"),
      validatePositiveBigDecimal(obj.totalLiabilityDTT, "totalLiabilityDTT"),
      validatePositiveBigDecimal(obj.totalLiabilityIIR, "totalLiabilityIIR"),
      validatePositiveBigDecimal(obj.totalLiabilityUTPR, "totalLiabilityUTPR"),
      validateLiableEntities(obj.liableEntities)
    ).mapN((_, _, _, _, _, _, _) => obj)

  private def validateNonNegativeInt(value: Int, fieldName: String): ValidatedNec[ValidationError, Int] =
    if (value >= 0) value.validNec
    else ValidationError(s"Path: /liabilities/$fieldName", s"$fieldName must be non-negative").invalidNec

  private def validatePositiveBigDecimal(value: BigDecimal, fieldName: String): ValidatedNec[ValidationError, BigDecimal] =
    if (value > 0) value.validNec
    else ValidationError(s"Path: /liabilities/$fieldName", s"$fieldName must be a positive number").invalidNec

  private def validateLiableEntities(
    entities: Seq[LiableEntity]
  ): ValidatedNec[ValidationError, Seq[LiableEntity]] =
    if (entities.isEmpty)
      ValidationError("Path: /liabilities/liableEntities", "liableEntities must not be empty").invalidNec
    else
      entities.zipWithIndex.map { case (entity, index) =>
        LiableEntityValidator.validate(entity).leftMap(_.map(e => e.copy(field = s"liableEntities[$index].${e.field}")))
      }.sequence
}


package uk.gov.hmrc.pillar2submissionapi.validation

import cats.data.ValidatedNec
import cats.implicits._
import uk.gov.hmrc.pillar2submissionapi.models.uktrsubmissions._

object LiabilityNilReturnValidator extends Validator[LiabilityNilReturn] {
  override def validate(obj: LiabilityNilReturn): ValidatedNec[ValidationError, LiabilityNilReturn] =
    validateEnum(obj.returnType, ReturnType.values, "returnType").map(_ => obj)

  private def validateEnum[T](value: T, validValues: Seq[T], fieldName: String): ValidatedNec[ValidationError, T] =
    if (validValues.contains(value)) value.validNec
    else ValidationError(s"Path: /liabilities/$fieldName", s"$fieldName has an invalid value").invalidNec
}


package uk.gov.hmrc.pillar2submissionapi.validation

import cats.data.ValidatedNec
import cats.implicits._
import uk.gov.hmrc.pillar2submissionapi.models.uktrsubmissions.LiableEntity

object LiableEntityValidator extends Validator[LiableEntity] {
  override def validate(obj: LiableEntity): ValidatedNec[ValidationError, LiableEntity] =
    (
      validateNonEmptyString(obj.ukChargeableEntityName, "ukChargeableEntityName"),
      validateNonEmptyString(obj.idType, "idType"),
      validateNonEmptyString(obj.idValue, "idValue"),
      validatePositiveBigDecimal(obj.amountOwedDTT, "amountOwedDTT"),
      validatePositiveBigDecimal(obj.amountOwedIIR, "amountOwedIIR"),
      validatePositiveBigDecimal(obj.amountOwedUTPR, "amountOwedUTPR")
    ).mapN((_, _, _, _, _, _) => obj)

  private def validateNonEmptyString(value: String, fieldName: String): ValidatedNec[ValidationError, String] =
    if (value.trim.isEmpty)
      ValidationError(fieldName, s"$fieldName is missing or empty").invalidNec
    else value.validNec

  private def validatePositiveBigDecimal(value: BigDecimal, fieldName: String): ValidatedNec[ValidationError, BigDecimal] =
    if (value <= 0) ValidationError(fieldName, s"$fieldName must be a positive number").invalidNec
    else value.validNec
}


package uk.gov.hmrc.pillar2submissionapi.controllers

import org.scalatest.matchers.should.Matchers
import org.scalatest.wordspec.AnyWordSpec
import org.scalatestplus.play.guice.GuiceOneAppPerSuite
import play.api.libs.json.Json
import play.api.test.Helpers._
import play.api.test.{FakeRequest, Helpers}
import uk.gov.hmrc.pillar2submissionapi.models.uktrsubmissions._

import java.time.LocalDate

class UktrSubmissionControllerSpec extends AnyWordSpec with Matchers with GuiceOneAppPerSuite {

  private val controller = new UktrSubmissionController(Helpers.stubControllerComponents())

  "UktrSubmissionController#submitUktr" should {

    "return Created for a valid UktrSubmissionData submission" in {
      val validData = Json.obj(
        "accountingPeriodFrom" -> "2023-01-01",
        "accountingPeriodTo"   -> "2023-12-31",
        "obligationMTT"        -> true,
        "electionUKGAAP"       -> false,
        "liabilities" -> Json.obj(
          "electionDTTSingleMember"  -> true,
          "electionUTPRSingleMember" -> false,
          "numberSubGroupDTT"        -> 2,
          "numberSubGroupUTPR"       -> 3,
          "totalLiability"           -> 1000.50,
          "totalLiabilityDTT"        -> 500.25,
          "totalLiabilityIIR"        -> 300.15,
          "totalLiabilityUTPR"       -> 200.10,
          "liableEntities" -> Json.arr(
            Json.obj(
              "ukChargeableEntityName" -> "Entity One",
              "idType"                 -> "TypeA",
              "idValue"                -> "ID123",
              "amountOwedDTT"          -> 250.00,
              "amountOwedIIR"          -> 150.00,
              "amountOwedUTPR"         -> 100.00
            )
          )
        )
      )

      val request = FakeRequest(POST, "/submitUktr").withJsonBody(validData)
      val result  = controller.submitUktr.apply(request)

      status(result)        shouldBe CREATED:                         Unit
      contentAsJson(result) shouldBe Json.obj("status" -> "Created"): Unit
    }

    "return Created for a valid UktrSubmissionNilReturn submission" in {
      val validNilReturn = UktrSubmissionNilReturn(
        accountingPeriodFrom = LocalDate.parse("2023-01-01"),
        accountingPeriodTo = LocalDate.parse("2023-12-31"),
        obligationMTT = false,
        electionUKGAAP = true,
        liabilities = LiabilityNilReturn(ReturnType.NIL_RETURN)
      )

      val request = FakeRequest(POST, "/submitUktr")
        .withJsonBody(Json.toJson(validNilReturn))

      val result = controller.submitUktr.apply(request)

      val _ = status(result) shouldBe CREATED: Unit
      val _ = contentAsJson(result) shouldBe Json.obj("status" -> "Created")
    }

    "return BadRequest when JSON is missing required fields" in {
      val invalidJson = Json.obj(
        "accountingPeriodFrom" -> "2023-01-01"
      )

      val request = FakeRequest(POST, "/submitUktr")
        .withJsonBody(invalidJson)

      val result = controller.submitUktr.apply(request)

      status(result)                                 shouldBe BAD_REQUEST:           Unit
      (contentAsJson(result) \ "message").as[String] shouldBe "Invalid JSON format": Unit

      val details = (contentAsJson(result) \ "details").as[Seq[String]]
      details should contain allElementsOf Seq(
        "Path: /accountingPeriodTo, Errors: error.path.missing",
        "Path: /obligationMTT, Errors: error.path.missing",
        "Path: /electionUKGAAP, Errors: error.path.missing",
        "Path: /liabilities, Errors: error.path.missing"
      ): Unit
    }

    "return BadRequest when liabilities validation fails for UktrSubmissionData" in {
      val invalidLiabilitiesJson = Json.obj(
        "accountingPeriodFrom" -> "2024-08-14",
        "accountingPeriodTo"   -> "2024-12-14",
        "obligationMTT"        -> true,
        "electionUKGAAP"       -> true,
        "liabilities" -> Json.obj(
          "electionDTTSingleMember"  -> true,
          "electionUTPRSingleMember" -> false,
          "numberSubGroupDTT"        -> -1,
          "numberSubGroupUTPR"       -> 3,
          "totalLiability"           -> -1000.99,
          "totalLiabilityDTT"        -> 500.25,
          "totalLiabilityIIR"        -> 0,
          "totalLiabilityUTPR"       -> 200.10,
          "liableEntities"           -> Json.arr()
        )
      )

      val request = FakeRequest(POST, "/submitUktr").withJsonBody(invalidLiabilitiesJson)
      val result  = controller.submitUktr.apply(request)

      status(result) shouldBe BAD_REQUEST: Unit
      val details = (contentAsJson(result) \ "details").as[Seq[String]]

      details should contain allElementsOf Seq(
        "Path: /liabilities/numberSubGroupDTT: numberSubGroupDTT must be non-negative",
        "Path: /liabilities/totalLiability: totalLiability must be a positive number",
        "Path: /liabilities/totalLiabilityIIR: totalLiabilityIIR must be a positive number",
        "Path: /liabilities/liableEntities: liableEntities must not be empty"
      ): Unit
    }

    "should return 400 BAD_REQUEST for malformed JSON structure" in {

      val malformedJson = Json.obj(
        "accountingPeriodFrom" -> "2024-08-14",
        "accountingPeriodTo"   -> "2024-12-14",
        "obligationMTT"        -> true,
        "electionUKGAAP"       -> true,
        "liabilities" -> Json.obj(
          "electionDTTSingleMember"  -> "true",
          "electionUTPRSingleMember" -> false,
          "numberSubGroupDTT"        -> "1",
          "numberSubGroupUTPR"       -> 3,
          "totalLiability"           -> 10000.99,
          "totalLiabilityDTT"        -> 500.25,
          "totalLiabilityIIR"        -> 300.15,
          "totalLiabilityUTPR"       -> 200.10,
          "liableEntities" -> Json.arr(
            Json.obj(
              "ukChargeableEntityName" -> "Entity One",
              "idType"                 -> "TypeA",
              "idValue"                -> "ID123",
              "amountOwedDTT"          -> 250.00,
              "amountOwedIIR"          -> 150.00,
              "amountOwedUTPR"         -> 100.00
            )
          )
        )
      )

      val request = FakeRequest(POST, "/submitUktr").withJsonBody(malformedJson)
      val result  = controller.submitUktr.apply(request)

      status(result)                                 shouldBe BAD_REQUEST:           Unit
      (contentAsJson(result) \ "message").as[String] shouldBe "Invalid JSON format": Unit

      val errorDetails = (contentAsJson(result) \ "details").as[Seq[String]]
      errorDetails should contain("Path: /liabilities/electionDTTSingleMember, Errors: error.expected.jsboolean"): Unit
      errorDetails should contain("Path: /liabilities/numberSubGroupDTT, Errors: error.expected.jsnumber"):        Unit
    }

    "return BadRequest when request body is not JSON" in {
      val request = FakeRequest(POST, "/submitUktr")
        .withTextBody("This is not JSON")

      val result = controller.submitUktr.apply(request)

      status(result)                                 shouldBe BAD_REQUEST:           Unit
      (contentAsJson(result) \ "message").as[String] shouldBe "Invalid JSON format": Unit
    }

    "return BadRequest when JSON has unknown fields" in {
      val jsonWithUnknownFields = Json.obj(
        "accountingPeriodFrom" -> "2023-01-01",
        "accountingPeriodTo"   -> "2023-12-31",
        "obligationMTT"        -> true,
        "electionUKGAAP"       -> false,
        "liabilities" -> Json.obj(
          "electionDTTSingleMember"  -> true,
          "electionUTPRSingleMember" -> false,
          "numberSubGroupDTT"        -> 2,
          "numberSubGroupUTPR"       -> 3,
          "totalLiability"           -> 1000.50,
          "totalLiabilityDTT"        -> 500.25,
          "totalLiabilityIIR"        -> 300.15,
          "totalLiabilityUTPR"       -> 200.10,
          "liableEntities" -> Json.arr(
            Json.obj(
              "ukChargeableEntityName" -> "Entity One",
              "idType"                 -> "TypeA",
              "idValue"                -> "ID123",
              "amountOwedDTT"          -> 250.00,
              "amountOwedIIR"          -> 150.00,
              "amountOwedUTPR"         -> 100.00,
              "unknownField"           -> "unexpected"
            )
          ),
          "unknownLiabilityField" -> "unexpected"
        ),
        "extraTopLevelField" -> "unexpected"
      )

      val request = FakeRequest(POST, "/submitUktr").withJsonBody(jsonWithUnknownFields)
      val result  = controller.submitUktr.apply(request)

      status(result) shouldBe BAD_REQUEST: Unit
      val details = (contentAsJson(result) \ "details").as[Seq[String]]

      details should contain allElementsOf Seq(
        "Path: /extraTopLevelField, Errors: unexpected field",
        "Path: /liabilities/unknownLiabilityField, Errors: unexpected field"
      ): Unit
    }

    "return BadRequest when date formats are invalid" in {
      val invalidDateJson = Json.obj(
        "accountingPeriodFrom" -> "01-01-2023", // Invalid date format
        "accountingPeriodTo"   -> "2023-12-31",
        "obligationMTT"        -> true,
        "electionUKGAAP"       -> false,
        "liabilities" -> Json.obj(
          "electionDTTSingleMember"  -> true,
          "electionUTPRSingleMember" -> false,
          "numberSubGroupDTT"        -> 2,
          "numberSubGroupUTPR"       -> 3,
          "totalLiability"           -> 1000.50,
          "totalLiabilityDTT"        -> 500.25,
          "totalLiabilityIIR"        -> 300.15,
          "totalLiabilityUTPR"       -> 200.10,
          "liableEntities" -> Json.arr(
            Json.obj(
              "ukChargeableEntityName" -> "Entity One",
              "idType"                 -> "TypeA",
              "idValue"                -> "ID123",
              "amountOwedDTT"          -> 250.00,
              "amountOwedIIR"          -> 150.00,
              "amountOwedUTPR"         -> 100.00
            )
          )
        )
      )

      val request = FakeRequest(POST, "/submitUktr")
        .withJsonBody(invalidDateJson)

      val result = controller.submitUktr.apply(request)

      status(result)                                 shouldBe BAD_REQUEST:           Unit
      (contentAsJson(result) \ "message").as[String] shouldBe "Invalid JSON format": Unit

      val errorDetails = (contentAsJson(result) \ "details").as[Seq[String]]
      errorDetails should contain("Path: /accountingPeriodFrom, Errors: error.expected.date.isoformat"): Unit
    }

    "return BadRequest for unknown submission type" in {
      val unknownTypeJson = Json.obj(
        "accountingPeriodFrom" -> "2023-01-01",
        "accountingPeriodTo"   -> "2023-12-31",
        "obligationMTT"        -> true,
        "electionUKGAAP"       -> false,
        "liabilities"          -> Json.obj("returnType" -> "UNKNOWN_TYPE")
      )

      val request = FakeRequest(POST, "/submitUktr").withJsonBody(unknownTypeJson)
      val result  = controller.submitUktr.apply(request)

      status(result)                                 shouldBe BAD_REQUEST:           Unit
      (contentAsJson(result) \ "message").as[String] shouldBe "Invalid JSON format": Unit

      val details = (contentAsJson(result) \ "details").as[Seq[String]]
      details should contain("Path: /liabilities/returnType, Errors: Unknown submission type: UNKNOWN_TYPE"): Unit
    }

    "return BadRequest when enums have invalid values" in {
      val invalidEnumJson = Json.obj(
        "accountingPeriodFrom" -> "2023-01-01",
        "accountingPeriodTo"   -> "2023-12-31",
        "obligationMTT"        -> true,
        "electionUKGAAP"       -> false,
        "liabilities"          -> Json.obj("returnType" -> "INVALID_ENUM")
      )

      val request = FakeRequest(POST, "/submitUktr").withJsonBody(invalidEnumJson)
      val result  = controller.submitUktr.apply(request)

      status(result)                                 shouldBe BAD_REQUEST:           Unit
      (contentAsJson(result) \ "message").as[String] shouldBe "Invalid JSON format": Unit

      val details = (contentAsJson(result) \ "details").as[Seq[String]]
      details should contain("Path: /liabilities/returnType, Errors: Unknown submission type: INVALID_ENUM"): Unit
    }

    "return BadRequest when UktrSubmissionNilReturn has different validation errors" in {
      val anotherInvalidNilReturnJson = Json.obj(
        "accountingPeriodFrom" -> "2023-01-01",
        "accountingPeriodTo"   -> "2023-12-31",
        "obligationMTT"        -> false,
        "electionUKGAAP"       -> true,
        "liabilities" -> Json.obj(
          "returnType" -> "ANOTHER_INVALID_RETURN_TYPE"
        )
      )

      val request = FakeRequest(POST, "/submitUktr").withJsonBody(anotherInvalidNilReturnJson)
      val result  = controller.submitUktr.apply(request)

      status(result)                                 shouldBe BAD_REQUEST:           Unit
      (contentAsJson(result) \ "message").as[String] shouldBe "Invalid JSON format": Unit

      val details = (contentAsJson(result) \ "details").as[Seq[String]]
      details should contain("Path: /liabilities/returnType, Errors: Unknown submission type: ANOTHER_INVALID_RETURN_TYPE"): Unit
    }

    "return BadRequest when UktrSubmissionData has validation errors" in {
      val invalidSubmissionDataJson = Json.obj(
        "accountingPeriodFrom" -> "2023-01-01",
        "accountingPeriodTo"   -> "2023-12-31",
        "obligationMTT"        -> true,
        "electionUKGAAP"       -> false,
        "liabilities" -> Json.obj(
          "electionDTTSingleMember"  -> true,
          "electionUTPRSingleMember" -> false,
          "numberSubGroupDTT"        -> -1,
          "numberSubGroupUTPR"       -> 3,
          "totalLiability"           -> -1000.50,
          "totalLiabilityDTT"        -> 500.25,
          "totalLiabilityIIR"        -> 0,
          "totalLiabilityUTPR"       -> 200.10,
          "liableEntities"           -> Json.arr()
        )
      )

      val request = FakeRequest(POST, "/submitUktr").withJsonBody(invalidSubmissionDataJson)
      val result  = controller.submitUktr.apply(request)

      status(result) shouldBe BAD_REQUEST: Unit
      val details = (contentAsJson(result) \ "details").as[Seq[String]]

      details should contain allElementsOf Seq(
        "Path: /liabilities/numberSubGroupDTT: numberSubGroupDTT must be non-negative",
        "Path: /liabilities/totalLiability: totalLiability must be a positive number",
        "Path: /liabilities/totalLiabilityIIR: totalLiabilityIIR must be a positive number",
        "Path: /liabilities/liableEntities: liableEntities must not be empty"
      ): Unit
    }

    "return BadRequest when UktrSubmissionNilReturn has validation errors" in {
      val invalidNilReturnJson = Json.obj(
        "accountingPeriodFrom" -> "2023-01-01",
        "accountingPeriodTo"   -> "2023-12-31",
        "obligationMTT"        -> false,
        "electionUKGAAP"       -> true,
        "liabilities" -> Json.obj(
          "returnType" -> "INVALID_RETURN_TYPE"
        )
      )

      val request = FakeRequest(POST, "/submitUktr").withJsonBody(invalidNilReturnJson)
      val result  = controller.submitUktr.apply(request)

      status(result)                                 shouldBe BAD_REQUEST:           Unit
      (contentAsJson(result) \ "message").as[String] shouldBe "Invalid JSON format": Unit

      val details = (contentAsJson(result) \ "details").as[Seq[String]]
      details should contain("Path: /liabilities/returnType, Errors: returnType has an invalid value"): Unit
    }

    "return BadRequest when UktrSubmissionNilReturn has validation errors in liabilities" in {
      val invalidNilReturnJson = Json.obj(
        "accountingPeriodFrom" -> "2023-01-01",
        "accountingPeriodTo"   -> "2023-12-31",
        "obligationMTT"        -> false,
        "electionUKGAAP"       -> true,
        "liabilities" -> Json.obj(
          "returnType" -> "INVALID_RETURN_TYPE" // Invalid value for returnType
        )
      )

      val request = FakeRequest(POST, "/submitUktr").withJsonBody(invalidNilReturnJson)
      val result  = controller.submitUktr.apply(request)

      status(result) shouldBe BAD_REQUEST: Unit

      val jsonResponse = contentAsJson(result)
      (jsonResponse \ "message").as[String] shouldBe "Invalid JSON format": Unit

      val details = (jsonResponse \ "details").as[Seq[String]]
      details should contain allElementsOf Seq(
        "Path: /liabilities/returnType, Errors: returnType has an invalid value"
      ): Unit
    }

    "return BadRequest when UktrSubmissionNilReturn has invalid liabilities" in {
      val invalidNilReturnJson = Json.obj(
        "accountingPeriodFrom" -> "2023-01-01",
        "accountingPeriodTo"   -> "2023-12-31",
        "obligationMTT"        -> false,
        "electionUKGAAP"       -> true,
        "liabilities" -> Json.obj(
          "returnType" -> "INVALID_RETURN_TYPE" // Invalid value for returnType
        )
      )

      val request = FakeRequest(POST, "/submitUktr").withJsonBody(invalidNilReturnJson)
      val result  = controller.submitUktr.apply(request)

      status(result) shouldBe BAD_REQUEST: Unit

      val jsonResponse = contentAsJson(result)
      (jsonResponse \ "message").as[String] shouldBe "Invalid JSON format": Unit

      val details = (jsonResponse \ "details").as[Seq[String]]
      details should contain("Path: /liabilities/returnType, Errors: returnType has an invalid value"): Unit
    }

    "return BadRequest for completely invalid UktrSubmissionNilReturn" in {
      val invalidNilReturnJson = Json.obj(
        "accountingPeriodFrom" -> "INVALID_DATE", // Invalid date format
        "liabilities" -> Json.obj(
          "returnType" -> "INVALID_RETURN_TYPE" // Invalid enum
        )
      )

      val request = FakeRequest(POST, "/submitUktr").withJsonBody(invalidNilReturnJson)
      val result  = controller.submitUktr.apply(request)

      status(result) shouldBe BAD_REQUEST: Unit

      val details = (contentAsJson(result) \ "details").as[Seq[String]]
      details should contain("Path: /liabilities/returnType, Errors: returnType has an invalid value"): Unit
    }

    "return BadRequest when UktrSubmissionNilReturn has invalid returnType" in {
      val invalidNilReturnJson = Json.obj(
        "accountingPeriodFrom" -> "2023-01-01",
        "accountingPeriodTo"   -> "2023-12-31",
        "obligationMTT"        -> false,
        "electionUKGAAP"       -> true,
        "liabilities" -> Json.obj(
          "returnType" -> "INVALID_RETURN_TYPE" // Invalid value for returnType
        )
      )

      val request = FakeRequest(POST, "/submitUktr").withJsonBody(invalidNilReturnJson)
      val result  = controller.submitUktr.apply(request)

      status(result) shouldBe BAD_REQUEST: Unit

      println((contentAsJson(result) \ "details").as[Seq[String]])
      val details = (contentAsJson(result) \ "details").as[Seq[String]]
      details should contain("Path: /liabilities/returnType, Errors: returnType has an invalid value"): Unit
    }

    "return BadRequest when JSON is missing required fields in liabilities" in {
      val invalidLiabilitiesJson = Json.obj(
        "accountingPeriodFrom" -> "2023-01-01",
        "accountingPeriodTo"   -> "2023-12-31",
        "obligationMTT"        -> true,
        "electionUKGAAP"       -> false,
        "liabilities"          -> Json.obj() // Empty liabilities
      )

      val request = FakeRequest(POST, "/submitUktr").withJsonBody(invalidLiabilitiesJson)
      val result  = controller.submitUktr.apply(request)

      status(result) shouldBe BAD_REQUEST: Unit
      val details = (contentAsJson(result) \ "details").as[Seq[String]]

      details should contain allElementsOf Seq(
        "Path: /liabilities/returnType, Errors: error.path.missing",
        "Path: /liabilities/totalLiabilityUTPR, Errors: error.path.missing",
        "Path: /liabilities/liableEntities, Errors: error.path.missing",
        "Path: /liabilities/electionUTPRSingleMember, Errors: error.path.missing",
        "Path: /liabilities/totalLiability, Errors: error.path.missing",
        "Path: /liabilities/electionDTTSingleMember, Errors: error.path.missing",
        "Path: /liabilities/numberSubGroupDTT, Errors: error.path.missing",
        "Path: /liabilities/totalLiabilityIIR, Errors: error.path.missing",
        "Path: /liabilities/totalLiabilityDTT, Errors: error.path.missing",
        "Path: /liabilities/numberSubGroupUTPR, Errors: error.path.missing"
      ): Unit
    }

  }
}


package uk.gov.hmrc.pillar2submissionapi.validation

case class ValidationError(field: String, error: String)


package uk.gov.hmrc.pillar2submissionapi.validation

import cats.data.ValidatedNec
import uk.gov.hmrc.pillar2submissionapi.validation.ValidationError

trait Validator[A] {
  def validate(obj: A): ValidatedNec[ValidationError, A]
}


